"""Parses the .DS_Store files generated by macOS.

.DS_Store files contain records of the different properties (fields) of the
files or directories of the directory of .DS_Store.  These fields can specify
things like modification dates, icons, backgrounds, comments, etc.  Each field
has a four-char name and variable length and type data.  Each file has a number
of unique fields.  See the second link below for the meaning of each field.

## Usage
```sh
python3 parse.py <.DS_Store file>
```

## More about .DS_Stores
Since .DS_Store formats are proprietary, there aren't official specifications
and current parsers and formats are more or less speculations.

It's worth saying that a large portion of the .DS_Store appears to be junk.
Maybe the OS writes to the places that are convenient and doesn't care about
.DS_Store sizes.

Below are some helpful links for .DS_Store.  I used some of them.
- Nice intro:
https://0day.work/parsing-the-ds_store-file-format/
- Very detailed, but a little out of date for the current macOS version:
https://metacpan.org/pod/distribution/Mac-Finder-DSStore/DSStoreFormat.pod
- Original, but a little out of date for the current macOS version:
https://wiki.mozilla.org/DS_Store_File_Format
"""

import sys
import warnings


# 'bool': bool
# 'shor': int
# 'long': int
# 'comp': int
# 'dutc': bytes  # TODO
# 'type': str (of length 4)
# 'blob': bytes
# 'ustr': str


class Record:

    def __init__(self, name, *args, **kwargs):
        self.name = name
        self.fields = dict(*args, **kwargs)

    def update(self, *args, **kwargs):
        self.fields.update(*args, **kwargs)

    def __repr__(self):
        kwargs = "".join(f", {key}={value!r}"
                         for key, value in self.fields.items())
        return (f'Record({self.name!r}{kwargs})')


class DSStore:

    def __init__(self, content):
        self.cursor = 0
        self.content = content
        self.records = []
        self.parse()

    def next_byte(self):
        data = content[self.cursor]
        self.cursor += 1
        return data

    def next_bytes(self, n):
        data = content[self.cursor:self.cursor + n]
        self.cursor += n
        return data

    def next_uint32(self):
        data = int.from_bytes(self.next_bytes(4),
                              byteorder='big', signed=False)
        return data

    def next_uint64(self):
        data = int.from_bytes(self.next_bytes(8),
                              byteorder='big', signed=False)
        return data

    def parse_header(self):
        # Alignment int
        alignment = self.next_uint32()
        if alignment != 0x00000001:
            warnings.warn(f'Alignment int {hex(alignment)} not 0x00000001')

        # Magic bytes
        magic = self.next_uint32()
        if magic != 0x42756431:
            warnings.warn(f'Magic bytes {hex(magic)} not 0x42756431')

        # Buddy allocator position & length
        # 0x4 for the alignment int
        self.allocator_offset = 0x4 + self.next_uint32()
        self.allocator_length = self.next_uint32()
        allocator_offset_repeat = 0x4 + self.next_uint32()
        if allocator_offset_repeat != self.allocator_offset:
            warnings.warn(f'Allocator offsets {hex(self.allocator_offset)} and'
                          f' {hex(allocator_offset_repeat)} unequal')

    def parse_allocator(self):
        self.cursor = self.allocator_offset

        # Offsets
        num_offsets = self.next_uint32()
        second = self.next_uint32()
        if second != 0:
            warnings.warn(f'Second int of allocator {hex(second)}'
                          ' not 0x00000000')
        self.offsets = [self.next_uint32() for _ in range(num_offsets)]

        self.cursor = self.allocator_offset + 0x408

        # Table of contents
        self.directory = {}
        num_keys = self.next_uint32()
        for _ in range(num_keys):
            key_length = self.next_byte()
            key = self.next_bytes(key_length).decode('ascii')
            self.directory[key] = self.next_uint32()
            if key != 'DSDB':
                warnings.warn(f"Directory contains non-'DSDB' key {key!r} and"
                              f' value {hex(self.directory[key])}')

        # Master node ID & offset
        if 'DSDB' not in self.directory:
            raise ValueError("Key 'DSDB' not found in table of contents")
        self.master_id = self.directory['DSDB']

        # Free list
        self.freelist = {}
        for i in range(32):
            values_length = self.next_uint32()
            self.freelist[1 << i] = [self.next_uint32()
                                     for _ in range(values_length)]

    def parse_tree(self, *, node_id=None):
        # The master node points to the root node and contains metadata
        # The B-tree contains nodes, which contain records of file properties
        # or nodes
        if node_id == 0:  # TODO
            return
        if node_id is None:
            master = True
            node_id = self.master_id
        else:
            master = False

        offset_and_size = self.offsets[node_id]
        self.cursor = 0x4 + (offset_and_size >> 0x5 << 0x5)
        # node size is 1 << (offset_and_size & 0x1f) TODO VALIDATE

        if master:
            # Master node
            self.root_id = self.next_uint32()
            self.tree_height = self.next_uint32()
            self.num_records = self.next_uint32()
            self.num_nodes = self.next_uint32()
            fifth = self.next_uint32()  # TODO: tree node page size?
            if fifth != 0x00001000:
                warnings.warn(f'Fifth int of master {hex(fifth)}'
                              ' not 0x00001000')
            self.parse_tree(node_id=self.root_id)
        else:
            next_id = self.next_uint32()
            num_records = self.next_uint32()
            for _ in range(num_records):
                if next_id:
                    # Has children
                    child_id = self.next_uint32()
                    current_cursor = self.cursor
                    self.parse_tree(node_id=child_id)
                    self.cursor = current_cursor

                name_length = self.next_uint32()
                name = self.next_bytes(name_length * 2).decode('utf-16be')
                field = self.next_bytes(4).decode('ascii')
                data = self.parse_data()
                for record in self.records:
                    if record.name == name:
                        record.update({field: data})
                        break
                else:
                    self.records.append(Record(name, {field: data}))

            # TODO
            if next_id:
                self.parse_tree(node_id=next_id)
            else:
                self.parse_tree(node_id=next_id)

    def parse_data(self):
        data_type = self.next_bytes(4).decode('ascii')
        if data_type == 'bool':
            return self.next_byte()
        elif data_type in {'shor', 'long'}:
            # short is also 4, with 2 0x00 bytes padding, for some reason
            return self.next_uint32()
        elif data_type == 'comp':
            return self.next_uint64()
        elif data_type == 'dutc':
            # TODO: this is the number of 1/65536 intervals from 1904
            return self.next_uint64()
        elif data_type == 'type':
            return self.next_bytes(4).decode('ascii')
        elif data_type == 'blob':
            data_length = self.next_uint32()
            return self.next_bytes(data_length)
        elif data_type == 'ustr':
            data_length = self.next_uint32()
            return self.next_bytes(2 * data_length).decode('utf-16be')
        else:
            raise NotImplementedError(f'Unrecognized data type {data_type}')

    def parse(self):
        self.parse_header()
        self.parse_allocator()
        self.parse_tree()


if __name__ == '__main__':
    if len(sys.argv) == 2:
        filename = sys.argv[1]
    elif len(sys.argv) == 1:
        print(f'File unspecified. Use python3 {sys.argv[0]} <.DS_Store file>'
              ' to specify file. Defaulting to .DS_Store in the current'
              ' directory...')
        filename = '.DS_Store'
    else:
        print(f'Usage: python3 {sys.argv[0]} <.DS_Store file>')
    with open(filename, 'rb') as file:
        content = file.read()
    ds_store = DSStore(content)
    for record in ds_store.records:
        print(record)
